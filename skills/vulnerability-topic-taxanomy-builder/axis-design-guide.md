# Axis Design Guide

How to derive classification axes from raw research findings.

---

## The Derivation Process

### Step 1: List All Techniques

After Phase 2 research, you should have 30-70+ distinct techniques in your notes. List them all, one per line.

Example (partial, for HTTP Smuggling):
```
- CL.TE priority conflict
- TE.CL priority conflict
- TE obfuscation via whitespace
- TE obfuscation via line folding
- CL.0 (back-end ignores CL)
- 0.CL (front-end ignores CL) 
- TE.0 (back-end ignores TE)
- H2.CL downgrade mismatch
- CRLF injection in H2 headers
- URL path parameter (;)
- Dot segment normalization diff
- Host header duplication
- JSON duplicate keys
- Multipart boundary tampering
- Bare LF acceptance
- Connection reuse
- Pause-based desync
- ...
```

### Step 2: Ask "What Component Does This Modify?"

For each technique, identify the structural target:

```
CL.TE priority conflict        → message framing (CL/TE interaction)
TE obfuscation via whitespace   → TE header structure
CL.0                           → message framing (zero-length)
URL path parameter (;)          → request URL
Host header duplication         → Host header
JSON duplicate keys             → body structure (JSON)
Bare LF acceptance              → low-level byte sequence
Connection reuse                → TCP connection state
Pause-based desync              → timing / connection behavior
```

**Group the answers** → These become your Axis 1 categories:
1. Message Framing
2. Header Obfuscation (TE, CL)
3. URL / Path
4. Host Identification
5. Body Structure / Content-Type
6. Connection / Protocol
7. Low-Level Parser
8. Payload Encoding

### Step 3: Ask "What Kind of Mismatch Does This Create?"

```
CL.TE → framing mismatch (where does the request end?)
URL path parameter → path mismatch (what resource is this?)
Host duplication → host mismatch (which server handles this?)
JSON duplicate keys → body semantics mismatch (what value does this key have?)
```

**Group the answers** → These become your Axis 2 types.

### Step 4: Ask "In What Architecture Is This Exploitable?"

```
CL.TE → proxy + origin (server-side HRS)
CL.0 → also browser → origin (client-side desync)
URL path → cache + origin (cache deception)
JSON duplicate keys → WAF + framework (WAF bypass)
```

**Group the answers** → These become your Axis 3 scenarios.

### Step 5: Verify Coverage

Every technique from Step 1 must have a position on all three axes. Create a spot-check table:

| Technique | Axis 1 | Axis 2 | Axis 3 |
|-----------|--------|--------|--------|
| CL.TE | §1-1 (Framing) | Framing mismatch | Server-side HRS |
| JSON dup keys | §5-3 (JSON) | Body semantics | WAF bypass |
| Pause-based | §1-4 (Timing) | Framing mismatch | Client-side desync |

If any technique has no clear Axis 1 home, you need a new category.

### Step 6: Name Categories

Category names must be:
- **Descriptive**: Reader knows what's inside without looking
- **Structural**: Named after the target, not the effect
- **Consistent in granularity**: All at roughly the same level of abstraction

```
✅ "Header Obfuscation Mutations"
✅ "Request-Line & URL Mutations"
✅ "Body Structure & Content-Type Mutations"

❌ "Advanced Techniques" (vague)
❌ "WAFFLED Findings" (source-named)
❌ "Dangerous Attacks" (effect-named)
```

---

## Common Pitfalls

### Pitfall 1: Too Many Top-Level Categories
If you have >10 top-level categories, some should be merged or one should become a subcategory of another.

**Fix**: Ask "Is X a specific instance of Y?" If yes, make X a subcategory of Y.

### Pitfall 2: Categories Overlap
If a technique fits equally well in two categories, your categories are not orthogonal enough.

**Fix**: Redefine the boundary. Usually one category should be about the *target component* and the other about the *enabling mechanism*.

### Pitfall 3: One Giant Category
If a category has 20+ subtypes and others have 3-4, it's too broad.

**Fix**: Split into subcategories. The giant category probably conflates multiple structural targets.

### Pitfall 4: Axes Mirror Each Other
If Axis 1 categories map 1:1 to Axis 2 types, they're not independent.

**Fix**: Axis 2 should be a *cross-cutting* property. Multiple Axis 1 categories should share the same Axis 2 type. Example: both "Header Obfuscation" and "Low-Level Parser" mutations can create "Framing mismatch" (Axis 2).

---

## Axis Design Quick Reference

| Question | Produces | Document Role |
|----------|----------|--------------|
| "What structural component is modified?" | Axis 1: Mutation Target | Main body sections (§1, §2, ...) |
| "What mismatch/bypass does it create?" | Axis 2: Discrepancy Type | Cross-cutting summary table |
| "In what deployment context is it exploitable?" | Axis 3: Attack Scenario | Scenario mapping table |
